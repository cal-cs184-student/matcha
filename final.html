<html>
<head>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Inter', sans-serif;
			margin: 0;
			padding: 0;
			background-color: #fff;
			color: #333;
		}

		h1 {
			text-align: center;
			margin-top: 40px;
			font-size: 2em;
		}

		.container {
			margin: 0 auto;
			padding: 60px 20%;
		}

		figure {
			text-align: center;
			margin: 30px 0;
		}

		img {
			display: inline-block;
			max-width: 100%;
			height: auto;
		}

		table {
			width: 100%;
			text-align: center;
			border-collapse: collapse;
			margin-top: 20px;
		}

		td {
			text-align: center;
			padding: 10px;
		}

		figcaption {
			font-size: 0.95em;
			color: #555;
			margin-top: 8px;
		}

		ul, ol {
			margin-left: 20px;
		}

		code {
			background-color: #f5f5f5;
			padding: 2px 4px;
			border-radius: 4px;
			font-family: monospace;
		}

		h2, h4 {
			border-bottom: 1px solid #ccc;
			padding-bottom: 6px;
		}
	</style>
</head>
<body>
	<div class="container">
        
        <h1>What in the World? (Team 60)</h1>
        <h4>Advika Bhike, Catherine Chu, Eshani Jha, Malavikha Sudarshan</h4>

        <p>GitHub: <a href="https://github.com/cal-cs184-student/matcha">https://github.com/cal-cs184-student/matcha</a></p>
        <p>Website: <a href="https://cal-cs184-student.github.io/matcha/final.html">https://cal-cs184-student.github.io/matcha/final.html</a></p>
        <p>Final Slides: <a href="https://docs.google.com/presentation/d/1ZaHTSO4sCubKaPMQhuTvd9Z5Uo-jNtgcxodGCnF9MSc/edit?usp=sharing">https://docs.google.com/presentation/d/1ZaHTSO4sCubKaPMQhuTvd9Z5Uo-jNtgcxodGCnF9MSc/edit?usp=sharing</a></p>
        <p>Final Video: <a href="https://youtu.be/S4y190PJRdA">https://youtu.be/S4y190PJRdA</a></p>
 
        <h2>Abstract</h2>
		<p>In this project, we designed new textures to render in Minecraft using Blockbench. We created two different themes of textures and features: Japan theme and Candy theme. The Japan theme includes textures such as cherry blossom leaves, spiral leaves and koi fish, and features such as a pastel green day sky and swaying trees. The Candy theme includes candy-themed trees and patterned sand, as well as features such as twinkling stars and flashing comets in the night sky, a reflective pink seawater, and a pastel pink day sky with clouds. We also blended features from both themes such as candy textures, swaying trees, and reflective water to create a Blended Fantasy theme. Finally, we simulated two types of watercolor-effect filters on the rendered scene, implementing Gaussian blurring and bilateral blurring for a color-bleeding effect. </p>
			
		
		
		<h2>Technical Approach</h2>

		<h3>Overview of Features</h3>

		<section>
			<h5>Japan Theme</h5>
			<ul>
			  <li>Japan-themed textures: trees, path, koi fish</li>
			  <li>Pastel green day sky with clouds</li>
			  <li>Swaying trees <strong>(a reach goal!)</strong></li>
			</ul>
		  </section>
		  
		  <section>
			<h5>Candy Theme</h5>
			<ul>
			  <li>Candy-themed textures: trees, path, sand</li>
			  <li>Pastel pink day sky with clouds</li>
			  <li>Pink seawater with reflection</li>
			  <li>Twinkling stars and flashing comets <strong>(a reach goal!)</strong></li>
			</ul>
		  </section>
		  
		  <section>
			<h5>Blended Theme</h5>
			<ul>
			  <li>Mixed candy tree texture</li>
			  <li>Pink seawater with reflection</li>
			  <li>Swaying trees</li>
			</ul>
		  </section>
		  
		  <section>
			<h5>Additional Effects</h5>
			<ul>
			  <li>Watercolor filter implemented using Gaussian blur and bilateral blur</li>
			</ul>
		  </section>

		<h3>Frameworks and Pipeline</h3>
		<p>
			Minecraft’s mod friendly architecture separates appearance into two orthogonal layers: resource packs and shader packs. A resource pack is a ZIP whose internal path always begins with <code>assets/</code>. 
			Below it sit <code>PNG</code> textures, block state <code>JSON</code> files, sound files, and more. Dropping a new image at <code>assets/minecraft/textures/block/grass_block_top.png</code> will override the grassy surface in 
			game without touching any code. A shader pack, by contrast, lives in the root level directory <code>shaderpacks/</code>. It contains raw <code>GLSL</code> files (<code>.vsh</code> for vertex, .<code>fsh</code> for fragment) under a <code>shaders/</code> 
			folder, plus a <code>shaders.properties</code> files that tells OptiFine which stages (<code>gbuffers_terrain</code>, <code>gbuffers_entities</code>, <code>composite</code>, etc.) should use which programs. </p>

		<p>
			OptiFine provides the bridge between Mojang’s fixed rendering pipeline and our custom code. At runtime it injects helpful uniforms (<code>worldTime</code>, <code>sunPosition</code>, <code>gbufferProjectionInverse</code>, <code>shadowtex0</code>, etc.) 
			into every stage, allowing us to reconstruct world space positions, sample depth buffers, or query the current biome without external libraries. Each stage writes its results to a numbered colortexN. Later 
			stages can then read those buffers, enabling advanced. For example, <code>gbuffers_terrain.fsh</code> might output raw albedo and normals to colortex0 and colortex1, while <code>composite.fsh</code> normalizes the results, 
			performs Gaussian blur, and writes the tone mapped result to the screen. Iterative debugging was done through the <code>F3 + T</code> reload key bind. To write our shader code, we started with open-source 
			code mimicking Minecraft’s inbuilt renders and modified the necessary <code>.fsh</code> and <code>.vsh</code> files.
		</p>
		<p>
			Blockbench sits one layer above this ecosystem, acting as the content authoring IDE. Here we can model and paint entities in a live PBR preview that emulates Minecraft’s lighting. Blockbench can also export 
			project meshes as a JSONs and textures as a PNGs to be dropped into the appropriate shader pack or resource pack. During our project we used this workflow to sculpt custom textures (e.g. cherry blossom log, 
			peppermint sand, and Lorax inspired fish).
		</p>
		  
		<h3>Textures</h3>

		<p>We designed and drew out textures for blocks and modified entities in Blockbench, for both the Candy and Japan-themed world. We set Blockbench’s Preview Scene feature to render and see assets in a simulated game environment before testing it in Minecraft. For our Candy-themed world, we made lollipop swirls, chocolate blocks and other bright, colourful, blocky textures with thick outlines. We also modified an existing entity of the tadpole in Minecraft to create a Lorax-like fish for our candy-themed world.
			For the Japan-themed world, we made much more subtle, abstract blocks of cobblestone, cherry blossoms, pink water and tree trunks.</p>

			<p>Here are some of the textures we designed:</p>		
			<div style="display: flex; flex-direction: column; align-items: center;">
			  <table style="width: 100%; text-align: center; border-collapse: collapse; margin-top: 0cm;">
				<tr>
				<td style="text-align: center;">
				  <img src="imgs/fish.jpeg" width="300px"/>
				  <figcaption>Fish from "The Lorax"</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="imgs/orangeswirl.jpeg" width="300px"/>
				  <figcaption>Orange Swirl</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="imgs/cherryblossom.png" width="200px"/>
				  <figcaption>Cherry Blossoms</figcaption>
				</td>
		<td style="text-align: center;">
				  <img src="imgs/peppermint_leaf.png" width="300px"/>
				  <figcaption>Peppermint Leaf</figcaption>
				</td>
				</tr>
			  </table>
			</div>

			<h3>Pink seawater with reflection</h3>
			<p>
			  We implemented the pink seawater with reflections by simulating pseudo-normal vectors of the water using cosine and sine functions and using that to calculate the Fresnel term. The Fresnel term approximates reflectivity based on view angle, with Shlick approximation:
			</p>
		  
			<pre><code>float fresnel(vec3 N, vec3 V) {
			float c = clamp(dot(N, V), 0.0, 1.0);
			return 0.06 + (1.0 - 0.06) * pow(1.0 - c, 5.0);
		  }</code></pre>
		  
			<p>
			  We lightly ray traced in 2D (30 steps):
			</p>
			<pre><code>vec3 traceSSR(vec2 uv, vec2 dir) {
			for (int i = 0; i < 30; ++i) {
			  uv += dir * 0.003;
			  if (texture2D(depthtex0, uv).r < 1.0)
				return texture2D(colortex0, uv).rgb;
			}
			return vec3(0.0);
		  }</code></pre>
		  
			<p>
			  Water and specular lighting were blended based on the Fresnel term:
			</p>
			<pre><code>vec3 blinnSpec(vec3 N, vec3 L, vec3 V) {
			vec3 H = normalize(L + V);
			float s = pow(max(dot(N, H), 0.0), 96.0);
			return vec3(s);
		  }</code></pre>
		  
			<p>
			  Main logic:
			</p>
			<pre><code>vec3 N = waterNormal(gl_FragCoord.xy / viewRes * 4.0, float(worldTime));
		  vec3 V = normalize(viewDir);
		  vec2 Ruv = reflect(V, N).xy;
		  float F = fresnel(N, V);
		  vec3 refl = traceSSR(gl_FragCoord.xy / viewRes, Ruv);
		  vec3 spec = blinnSpec(N, sunDir, V);
		  vec3 pink = vec3(1.0, 0.55, 0.75);
		  vec3 noise = vec3(hash(gl_FragCoord.xy * 21.7) * 0.02);
		  vec3 colour = mix(pink, refl, F) + spec + noise;
		  gl_FragColor = vec4(normalize(colour), 1.0);</code></pre>
		  
			<p>
			  Vertex shader input:
			</p>
			<pre><code>// gbuffers_water.vsh
		  varying vec3 viewDir;
		  void main() {
			vec4 pos = gl_ModelViewMatrix * gl_Vertex;
			viewDir = -pos.xyz;
			gl_Position = ftransform();
		  }</code></pre>
		  		  
			<h3>Swaying Trees</h3>
			<p>
				To code swaying trees, we remembered that vertex shaders transform vertex positions from Homework 4 Part 5: Shaders. 
				Finding the corresponding file in charge of terrain <code>gbuffers_terrain.vsh</code>, we changed up the code to add displacements to relevant vertices and create a swaying motion for tree leaves. We calculated the motion using a sine function that varies over time (<code>frameTimeCounter</code>), vertex position (<code>gl_Vertex.x</code> and <code>gl_Vertex.z</code>, not in vertical y direction to realistically mimic gravity) and a scaling factor (<code>windStrength</code>). 
				Then, we make sure only tree leaves are affected, computing a heuristic <code>isLeaf</code> that is closer to 1 for leaf-like green colors and 0 otherwise. The displacement vector becomes motion weighted by <code>isLeaf</code> and different scaling factors per coordinate (less in y direction), and is finally added to the vertex position before its transformation into camera space. </p>
				<img src="imgs/code_trees_swaying.png">
		  
			<h3>Watercolor filter effect</h3>

			<img src="compositefsh for watercolor bilateral.png">

			<img src="watercolrogaussian.png">

			<p>
				The blurring effect is created from an application of convolution (as learned in Lecture 3), where we use 
				a 5x5 size kernel to estimate the value of one pixel. For both effects, only the <code>composite.fsh</code> 
				file was edited, and the <code>shaders.properties</code> file was updated to use the new composite file 
				instead of the default one.
			  </p>
			
			  <p>
				For <strong>Gaussian blurring</strong>, the weights in the convolution kernel are determined solely by the 
				spatial weight, <code>e^((-x² - y²) / 2.0)</code>, where (x, y) represents the pixel associated with that 
				weight. For each pixel (a, b), we compute a weighted average of all the neighboring pixels’ textures within 
				a 2-pixel radius surrounding (a, b). Additionally, we raise the result to the 0.9<sup>th</sup> power to make 
				the image softer. This final result is the final texture for that pixel.
			  </p>
			
			  <p>
				<strong>Bilateral blurring</strong>, on the other hand, uses weights that correspond to both spatial weight, 
				<code>e^((-x² - y²) / (2.0 * s₁²))</code>, and color weight, <code>e^((-c²) / (2.0 * s₂²))</code>, where 
				<code>c</code> represents the difference between the sample color (x, y) and center color (a, b), and 
				<code>s₁</code> and <code>s₂</code> represent constant factors controlling how much we want to weight spatial 
				and color difference respectively. We also compute a weighted average of these samples and adjust the tone by 
				raising the result to the 0.9<sup>th</sup> power before setting it as the pixel’s final texture value.
			  </p>
		<h3>Gradient sky that changes color from day to night </h3>
		<p>To create a pastel themed sky that has a blend of two colors and changes according to whether it is night or day, we used a cosine function to map Minecraft’s internal clock represented by <code>worldTime</code> to a specific time of the day. We defined what we wanted the top of the sky (the zenith) and the horizon to look like (either cotton-candy pink and soft lavender in the morning and pastel purplish pink and deep lavender in the night, for the horizon and zenith respectively). Then, we interpolated across these values using the output of the cosine function as our parameter. This final interpolated color is outputted as the color of our sky. Definitely a really pretty implementation of the concept of linear interpolation that we learned about in class! </p>

		<h3>Fog and Clouds</h3>
		<p>
		  This feature lives in two shaders:
		</p>
		<ul>
		  <li><code>gbuffers_sky.fsh</code> – draws the horizon-to-zenith sky gradient and first-pass clouds.</li>
		  <li><code>composite.fsh</code> – applies fog based on depth after rendering opaque geometry.</li>
		</ul>
	  
		<h4>First-Pass Clouds (<code>gbuffers_sky.fsh</code>)</h4>
		<p>
		  To simulate fluffy clouds, we reused the 2D value noise from our starfield shader but sampled at a lower frequency to create slow, large-scale puffs. We multiplied two octaves of noise for more natural variation and softened the edges using <code>smoothstep</code>.
		</p>
		<pre><code>vec2 uv = (frag.xy + vec2(worldTime * 0.00003, 0.0)) * 0.0015;
	  float density = noise(uv) * noise(uv * 2.0);          // fractal detail
	  float mask = smoothstep(0.45, 0.65, density);         // soft edge
	  </code></pre>
	  
		<p>
		  We then blended in a cloud color based on time of day. The clouds are teal during the day and a muted blue-grey at night:
		</p>
		<pre><code>vec3 cloudDay = vec3(0.80, 1.00, 0.95);
	  vec3 cloudNight = vec3(0.15, 0.25, 0.35);
	  vec3 cloudCol = mix(cloudNight, cloudDay, dayFrac);
	  
	  skyCol = mix(skyCol, cloudCol, mask * 0.6); // 60% opacity cap
	  </code></pre>
	  
		<p>
		  This 60% cap makes sure clouds remain translucent enough to show stars during dusk or dawn.
		</p>
	  
		<h4>Exponential Fog (<code>composite.fsh</code>)</h4>
		<p>
		  We added distance-based fog in the composite pass using view-space depth from the G-buffer. The fog strength was computed using an exponential function:
		</p>
		<pre><code>float fogFactor = 1.0 - exp(-z * fogDensity);  // e^(-λz)
	  fogFactor = clamp(fogFactor, 0.0, 1.0);
	  </code></pre>
	  
		<p>
		  Fog is denser at night and lighter during the day, controlled by <code>dayFrac</code>:
		</p>
		<pre><code>float fogDensity = mix(0.002, 0.0005, dayFrac); // thick at night
	  </code></pre>
	  
		<p>
		  To keep the fog color consistent with the sky, we sampled the same horizon-to-zenith gradient used for the sky shader, using screen-space height:
		</p>
		<pre><code>float v = frag.y / viewHeight;
	  vec3 fogCol = mix(horizonCol, zenithCol, v);  // pulled from sky pass
	  </code></pre>
	  
		<p>
		  Since both the sky and fog use <code>dayFrac</code>, the fog transitions naturally—reddish at sunset, teal at midnight.
		</p>
	  
		<h4>Final Fog Blend</h4>
		<p>
		  The fog was blended with the scene color, and cloud shadows were optionally darkened to make distant terrain fade under clouds:
		</p>
		<pre><code>vec3 scene = texture2D(colortex0, screenUV).rgb;
	  vec3 fogged = mix(scene, fogCol, fogFactor);
	  
	  float cloudShadow = texture2D(skySampler, screenUV).a;
	  fogged = mix(fogged, fogged * 0.9, cloudShadow * 0.4);
	  
	  gl_FragColor = vec4(fogged, 1.0);
	  </code></pre>

		<h3>Twinkling Stars and Flashing Comets</h3>
			<p>
			  Stars were grid-based and hashed to remain stable across frames:
			</p>
			<pre><code>float h = hash(floor(starUV));
		  if (h > 0.982) { /* small star */ }
		  if (h > 0.9975) { /* big flare */ }</code></pre>
			<p>
			  We did this for the twinkling effect:
			</p>
			<pre><code>float tw   = 0.5 + 0.5 * sin(worldTime*0.025 + h*80.0);
		  float halo = smoothstep(0.32, 0.0, length(fract(starUV) - 0.5));
		  skyCol = mix(skyCol, starC, halo * tw * starPhase);</code></pre>
		  
			<p>
			  Large stars added cross flares:
			</p>
			<pre><code>float flare = (smoothstep(0.35, 0.0, abs(f.x)) +
						 smoothstep(0.35, 0.0, abs(f.y))) * 0.5;
		  skyCol = mix(skyCol, bigC, (halo+flare) * twBig * starPhase);</code></pre>
		  
			<p>
			  And we added this line for stars to fade in and out smoothly:
			</p>
			<pre><code>float starPhase = max(0.0, (0.6 - dayFrac) / 0.6);</code></pre>
	

		<h2>Problems Encountered & Solutions</h2>

		<h3>Terrain Disappearing</h3>
		<p>One error that we ran into was the terrain going missing while we were editing the vertex shaders. We tackled this by debugging exactly how we were editing the vertex positions, making sure that we were computing in the right spaces and scaling properly. For example, we realized that the line <code>gl_Position = ftransform();</code> was actually short for projecting a vertex from object/model space into camera space, then changed our approach accordingly to displace our vertices before this projection step.</p>
		<img src="imgs/no_terrain_error.png">

		<h3>Excess Blur Effect</h3>
		<p> While creating the watercolor effect, we initially only implemented Gaussian blurring and found the blur to be overpowering to the point where the whole screen was green and the whole screen was blue (depending on whether we were looking at a tree or the sky). To resolve this, we played around with different kernel sizes. We started out with a 10x10 kernel, which was really blurry, and then switched to a 3x3 kernel at some point, which ended up being too small to render a blur. We then reverted to the 5x5 kernel, which ended up being more distinct. This issue was also the motivation behind exploring different types of blurring effects, such as bilateral blurring, since we could preserve color between edges better. The hyperparameters we chose for bilateral blurring are shown in the code above. 
		</p>

		<h3>Knowing Which Files To Edit</h3>
		<p> When tinting the sky, we originally just tried to change the main function in gbuffers_sky.fsh to return the color pink, using the logic that the function would just return a vector that mapped to the color pink. But it wasn’t rendering quickly, and through referencing code from Minecraft Shader Wiki, we realized none of those files actually changed gbuffers_sky.fsh and they actually overwrote the sky variable in the composite.fsh file.  		</p>

		<h3>Lessons Learned</h3>
		<p>One of the first lessons that we learned was how to familiarize ourselves with the relevant software, shader documentation and GLSL language for our project. To set up rendering in Minecraft, we spent a decent amount of time researching which software tools to install (e.g. Minecraft, Optifine, Forge), and ultimately chose Minecraft with Optifine because of its built-in support for coding new GLSL shaders. It took us a couple of tries to install and set up compatible versions of Minecraft and Optifine, but this whole process taught us how to look up available resources and piece together the ones that best suited our goals. We also looked into the different Minecraft shader files and learned the order in which they render in a game – by taking the time to study the existing codebase and rendering engine, we got a good idea of exactly which shaders to edit for each of our ideas. While implementing our ideas, we learned to apply the concepts that we learned in class about texture mapping, lighting (Blinn Phong shading, one-bounce global illumination, reflection across materials) and shaders (cloth simulation vertex and fragment). We were excited to build upon these, such as trying to implement reflection off of a water surface while following Minecraft’s specific documentation, or simulating swaying trees by first editing the vertex shader for tree leaves to then displace and pass on per-vertex positions to the corresponding fragment shader.		</p>

		<h2>Results</h2>
		<h5>Starting Point Shader Codebase</h5>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/LAoX5wjT_rA"
				title="Shader Codebase" frameborder="0" allowfullscreen></iframe>
		
		<h5>Japan Theme Features</h5>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/9ccCZc4hh-8"
				title="Japan Features" frameborder="0" allowfullscreen></iframe>
		
		<h5>Candy Theme Features</h5>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/snVh_I00oIY"
				title="Candy Features" frameborder="0" allowfullscreen></iframe>
		
		<h5>Watercolor Shader Effect</h5>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/PrVY7SR8UXc"
				title="Watercolor Effect" frameborder="0" allowfullscreen></iframe>
		
		<h5>Blended Theme (Fantasy)</h5>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/jnLRiRvoBjI"
				title="Blended Theme" frameborder="0" allowfullscreen></iframe>

				<h5 style="text-align: center;">Twinkling Stars & Flashing Comets</h5>
				<div style="display: flex; flex-direction: column; align-items: center;">
				  <table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
					  <td>
						<img src="imgs/flashing_lights.gif" width="300px"/>
						<figcaption>Flashing Lights</figcaption>
					  </td>
					  <td>
						<img src="imgs/flashing_stars.gif" width="300px"/>
						<figcaption>Sparkling Stars</figcaption>
					  </td>
					  <td>
						<img src="imgs/flashing_stars_2.gif" width="300px"/>
						<figcaption>Stars and Lights</figcaption>
					  </td>
					</tr>
				  </table>
				</div>
				<h5 style="text-align: center;">Pink Sea Reflection</h5>
				<div style="display: flex; flex-direction: column; align-items: center;">
				  <table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
					  <td>
						<img src="imgs/candy_sea.gif" width="400px"/>
						<figcaption>Pink Sea Surface</figcaption>
					  </td>
					  <td>
						<img src="imgs/candy_sea_below_lvl.gif" width="400px"/>
						<figcaption>Underwater View</figcaption>
					  </td>
					</tr>
				  </table>
				</div>
				<h5 style="text-align: center;">Swaying Trees</h5>
				<div style="display: flex; flex-direction: column; align-items: center;">
				  <table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
					  <td>
						<img src="imgs/swaying_tree.gif" width="300px"/>
						<figcaption>Candy Tree Swaying</figcaption>
					  </td>
					  <td>
						<img src="imgs/swaying_tree_2.gif" width="300px"/>
						<figcaption>Tree Wind Motion</figcaption>
					  </td>
					  <td>
						<img src="imgs/swaying_tree_3.gif" width="300px"/>
						<figcaption>Japan Tree Animation</figcaption>
					  </td>
					</tr>
				  </table>
				</div>

				<h5 style="text-align: center;">Watercolor Effects</h5>
				<div style="display: flex; flex-direction: column; align-items: center;">
				  <table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
					  <td>
						<img src="imgs/watercolor_effect.png" width="400px"/>
						<figcaption>Watercolor (Gaussian Blur)</figcaption>
					  </td>
					  <td>
						<img src="imgs/watercolor_effect_bilateral.png" width="400px"/>
						<figcaption>Watercolor (Bilateral Filter)</figcaption>
					  </td>
					</tr>
				  </table>
				</div>
				
				<p>
					One of our main goals with the Candy-Sky rendering effects was to keep everything running smoothly in real time—even with added features like colorful clouds, soft fog, and dynamic skies. From the start, we set a hard cap: each shader pass couldn't take more than about <strong>0.2 ms</strong> on a 1080p screen, so we could consistently hit <strong>60 FPS</strong> (i.e., one frame every 16 ms).
				  </p>
				
				  <p>
					To stick to this limit, we used a few clever tricks:
					<ul>
					  <li><strong>No texture lookups</strong> for noise or height—just math. All clouds and stars use lightweight value-noise or trig functions.</li>
					  <li><strong>No expensive loops</strong>—we capped things like SSR (screen-space reflection) at 30 steps max and avoided loops entirely for stars and clouds.</li>
					  <li><strong>Reused variables</strong>—we calculate values like <code>dayFrac</code> (day/night blend factor) once and share it across shaders for fog, horizon color, and clouds.</li>
					</ul>
				  </p>
				
				  <h3>Real-World Performance</h3>
				
				  <p>
					We tested our shaders on two systems:
				  </p>
				  <ul>
					<li><strong>NVIDIA GeForce GTX 1660 (6 GB)</strong> – mid-range GPU, tested in Minecraft 1.20.4 with OptiFine G10</li>
					<li><strong>AMD Ryzen 7 7840U (780M integrated graphics)</strong> – no discrete GPU</li>
				  </ul>
				
				  <p>
					Both systems kept frame rates well above 60 FPS, even in high-stress scenes (lots of foliage, water reflections, or combat particles).
				  </p>
				
				  <img src="imgs/62_fps.png" alt="Frame rate holding at 62 FPS in a complex scene">
				  <p><em>Frame rate steady at 62 FPS on integrated graphics</em></p>
				
				  <img src="imgs/97_fps.png" alt="Frame rate spiking to 97 FPS in a simpler scene">
				  <p><em>Frame rate peaks at 97 FPS on mid-range GPU</em></p>
	
		<h2>References</h2>
		<ul>
			<li><a href="https://github.com/shaderLABS/Base-330/tree/main/shaders" target="_blank">
				shaderLABS Base-330 GitHub Repository</a></li>
			<li><a href="http://www.cs.princeton.edu/courses/archive/fall07/cos597B/papers/kopf-solid-texture.pdf">Solid Texture Synthesis from 2D Exemplars</li>
			<li><a href="https://youtu.be/dSS5HuSr4SQ?si=XbviSwVSCmP1UrQZ">Minecraft Shaders Tutorial</li>
			<li><a href="https://www.youtube.com/watch?v=HHMJevNEYPc">Minecraft Shaders with Realistic Lighting Tutorial</li>
			<li><a href="https://www.9minecraft.net/bsl-shaders/#:~:text=,world%20for%20a%20more%20realistic" target="_blank">BSL Shaders on 9Minecraft</a></li>
			<li><a href="https://www.youtube.com/watch?v=NCptEJ1Uevg&ab_channel=OGLDEV" target="_blank">GLSL Tutorial (OGLDEV YouTube)</a></li>
			<li><a href="https://shaderlabs.org/wiki/Rendering_Pipeline_(OptiFine,_ShadersMod)#:~:text=Composite%20%28%60composite" target="_blank">ShaderLabs: OptiFine Rendering Pipeline (Composite)</a></li>
			<li><a href="https://www.rockpapershotgun.com/best-minecraft-shaders#:~:text=At%20the%20time%20of%20writing%2C,without%20spending%20ages%20tweaking%20settings" target="_blank">Best Minecraft Shaders – Rock Paper Shotgun</a></li>
			<li><a href="https://minecraft.fandom.com/wiki/Shaders#:~:text=Shaders%20are%20written%20in%20the,bloom%2C%20god%20rays%2C%20and%20blur" target="_blank">Minecraft Fandom: Shaders</a></li>
			<li><a href="https://shaderlabs.org/wiki/Rendering_Pipeline_(OptiFine,_ShadersMod)#:~:text=things%20like%20chests%20and%20banners,There%20are%20a%20few%20other" target="_blank">ShaderLabs: OptiFine Shader Pipeline (Extended)</a></li>
			<li><a href="https://www.9minecraft.net/tag/minecraft-1-21-4-shaders/" target="_blank">Minecraft 1.21.4 Shaders – 9Minecraft</a></li>
		  </ul>


		</ul>

		<h2>Contributions</h2>
	<strong>Advika Bhike:</strong> 
				<ul>
					<li>Created textures for Japan theme (trees, paths, koi fish) in Blockbench</li>
					<li>Coded watercolor effect in <code>composite.fsh</code> and <code>shader.properties</code></li>
					<li>Contributed to writeup, video, and slides</li>
				</ul>
	<strong>Catherine Chu:</strong>
	<ul>
		<li>Created prototype of Japan-themed world with cherry blossom trees in Blockbench</li>
		<li>Coded animation of trees swaying in <code>gbuffers_terrain.vsh</code></li>
		<li>Contributed to writeup, video, and slides</li>
	  </ul>

	<strong>Eshani Jha:</strong> 
	<ul>
		<li>Created textures for Candy theme (trees, paths, sand) in Blockbench</li>
		<li>Coded reflective pink sea in <code>gbuffers_water.vsh</code>, <code>gbuffers_water.fsh</code>, <code>final.fsh</code>, <code>final.vsh</code></li>
		<li>Coded stars and comets in <code>gbuffers_skybasic.vsh</code>, <code>gbuffers_skybasic.fsh</code>, <code>composite.fsh</code>, <code>composite.vsh</code></li>
		<li>Contributed to writeup, video, and slides</li>
	  </ul>
	<strong>Malavikha Sudarshan:</strong>
	<ul>
		<li>Created textures for Japan theme (trees, paths) in Blockbench</li>
		<li>Compiled writeup, images, and videos into webpage</li>
		<li>Contributed to writeup, video, and slides</li>
	  </ul>

</body>
</html>
